// Document to help understand pf code

------------------
Index
------------------

1. Files
2. Crucial Concepts
3. Structs
4. Functions
5. Other

------------------
Files
------------------

User side is located in sbin/pfctl
Kernel side is located in sys/netpfil/pf

Files in user space:

    parse.y    // Parser of configuration file, yakk language translated into C at compile time
    pfctl_parser.c // Responsible for parsing and sending configuration to ioctl
    pfctl_parser.h // heeader file for pfctl_parser
    pfctl.c // All pfctl options and configurations are written here
    pfctl.h // header file for pfctl.c
    pf.os // Operating System fingerprints (the data)
    pfctl_optimize.c
    pfctl_qstats.c
    pfctl_table.c
    pf_print_state.c
    pfctl_altq.c // ALTQ scheduler
    pfctl_osfp.c // OS fingerprinting (algorithms)
    pfctl_radix.c
    pfctl.8 // man page for pfctl

Files in kernel space:

    pf.c    // main kernel side of pf
    pf.h    // header file
    pf_ioctl.c  // code responsible for COPYIN and similar ioctl commands inside PF
    if_pflog.c // ifconfig pflog0
    if_pfsync.c // sync 2 PF firewalls
    in4_cksum.c
    pf_altq.h // ALTQ scheduler
    pf_if.c
    pf_lb.c
    pf_mtag.h
    pf_norm.c // Normalization of packets
    pf_osfp.c // OS fingerprinting
    pf_ruleset.c // defined main anchor and main ruleset
    pf_table.c

------------------------
Crucial Concepts:
------------------------

Files and functions responsible for communication between kernel and user space are:
    pf_ioctl.c, pfvar.h, ioctl, pfctl_trans, /dev/pf

pfctl_trans is one of the functions calling ioctl for communication between kernel and user space.

Once packet is receieved depending on the type of the protocol, it is used with switch case to decide how to handle it further.
That is decided in pf_test in sys/netpfil/pf/pf.c. Aditional functions do the actual testing, like pf_test_tcp, pf_test_udp, etc.

Main configuration file (pf.conf) is considered to be main (or root) anchor (anchor without a parent) with it's own ruleset. If there are aditional anchors
they are created as child anchors.

Inside of pf_ioctl.c are the functions like shutdown_pf pf_load pf_unload and similar

In pfvar.h "struct pf_pdesc" is declared, where packet description is stored. Stuff like source or destination address from packet header.

After config is parsed rules are passed to kernel with ioctl calls. Pseudo device for comunication between user space an kernel is /dev/pf

------------------------
Structs
------------------------

struct pf_anchor {		//declaration located in sys/net/pfvar.h
   RB_ENTRY(pf_anchor)  entry_global;
   RB_ENTRY(pf_anchor)  entry_node;
   struct pf_anchor  *parent;
   struct pf_anchor_node  children;
   char       name[PF_ANCHOR_NAME_SIZE];
   char       path[MAXPATHLEN];
   struct pf_ruleset  ruleset
   int      refcnt;  /* anchor rules */
   int      match; /* XXX: used for pfctl black magic */
 };

struct pf_ruleset {		//declaration located in sys/net/pfvar.h
   struct {
     struct pf_rulequeue  queues[2];
     struct {
       struct pf_rulequeue *ptr;
       struct pf_rule    **ptr_array;
       u_int32_t    rcount;
       u_int32_t    ticket;
       int      open;
     }      active, inactive;
   }      rules[PF_RULESET_MAX];
   struct pf_anchor  *anchor;
   u_int32_t    tticket;
   int      tables;
   int      topen;
 };

struct pf_addr { 		//declaration located in sys/net/pfvar.h
   union {
     struct in_addr    v4;
     struct in6_addr   v6;
     u_int8_t    addr8[16];
     u_int16_t   addr16[8];
     u_int32_t   addr32[4];
   } pfa;        /* 128-bit address */

struct pf_rule //declaration located in sys/net/pfvar.h

------------------------
Functions
------------------------
// User side functions and description

// kernel side functions and description

pf_test(int dir, int pflags, struct ifnet *ifp, struct mbuf **m0, struct inpcb *inp)

    Declared in pf.c and is responsible for deciding what operations are done on the packet
    depending on the protocol
    int dir is integer returned from "dev = open("/dev/pf", O_RDWR);"
    m is used as variable of a single packet, so mbuff in this case represents an array of pointers on packets

pf_test6(int dir, int pflags, struct ifnet *ifp, struct mbuf **m0, struct inpcb *inp)
    Declared in pf.c, similar to pf_test, but for IPv6

pf_test_rule(struct pf_rule **rm, struct pf_state **sm, int direction,
    struct pfi_kif *kif, struct mbuf *m, int off, struct pf_pdesc *pd,
    struct pf_rule **am, struct pf_ruleset **rsm, struct inpcb *inp)

    Declared in pf.c and responsible for testing if rule applies to the received packet

pf_get_pool(char *anchor, u_int32_t ticket, u_int8_t rule_action,
    u_int32_t rule_number, u_int8_t r_last, u_int8_t active,
    u_int8_t check_ticket)

    Declared in pf_ioctl.c

pfioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flags, struct thread *td)

    Declared in pf_ioctl.c


------------------------
Other
------------------------

For control of pf use pfctl, and for dummynet control of pipes queues and similar use dnctl

pf_addr_dir // pipes

kif (kernel interface)

counters

*mbuff // mbuff represents an array of pointers on packets
